---
title: "HW #1"
subtitle: "Interpreting `{ggplot2}` code"
description: "Assigned Wed 01/07/2026 | Due Wed 01/14/2026"
author: "Hylaea Miller"
toc: true
code-line-numbers: true
editor_options: 
  chunk_output_type: console
---

::: callout-tip
## Some notes before you get started

-   **Be sure to install any packages** in the Setup chunk that you don't already have.
-   **Leave the code chunk options, `eval: false` and `echo: true`, set as they are.** The final infographic has been intentionally optimized (e.g., text size, spacing) for saving and viewing as a PNG file, not for display in the Plots pane or within a rendered Quarto document. As a result, the text in each individual ggplot may appear too large when viewed in the Plots pane, but will be correctly sized in the exported PNG. We’ll talk more about the nuances of saving ggplots (and why these differences occur) in a later lab section.
-   **Questions that reference line numbers (e.g., Question #1) refer to the line numbers shown in the rendered code chunks.** You will need to render the document to view these line numbers.
-   Some answers may become clearer once you’ve looked ahead at the code further down in the script. **Consider revisiting questions as you go.**
:::

## I. Setup

```{r}
#| eval: false
#| echo: true

library(colorspace)
library(geofacet) 
library(ggtext) 
library(glue) 
library(grid)
library(magick)
library(patchwork) 
library(scales) 
library(showtext) 
library(tidyverse) 

ufo_sightings <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2023/2023-06-20/ufo_sightings.csv')
places <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2023/2023-06-20/places.csv')

alien <- c("#101319", "#28ee85")
bg <- alien[1]
accent <- alien[2]

ufo_image <- magick::image_read(path = here::here("images", "ufo.png")) 

sysfonts::font_add_google(name = "Orbitron", family = "orb")
sysfonts::font_add_google(name = "Barlow", family = "bar")

sysfonts::font_add(family = "fa-brands", regular = here::here("fonts", "Font Awesome 6 Brands-Regular-400.otf"))
sysfonts::font_add(family = "fa-solid", regular = here::here("fonts", "Font Awesome 6 Free-Solid-900.otf"))

showtext::showtext_auto(enable = TRUE)
```

1.  **What is the author defining in lines 15-17? Where else in the code do these defined variables show up? What advantage(s) is there to defining these values here, as variables, rather than defining the values directly throughout the script?**

    -   In line 15, the author is defining two hex color codes and assigning them to the `alien` vector. In line 16, they assign the first hex color from `alien` to the `bg` (background) variable, and in line 17, they assign the second color from `alien` to the `accent` variable. These variables are used later throughout the script wherever colors are needed, for example, in plot backgrounds, text colors, and theme elements. Some advantages of using this approach are consistency, easy updates, and readability.

2.  **In your own words, explain what the function, `font_add_google()`, does. What's the difference between the two arguments, `name` and `family`?**

    -   The function allows you to add Google Fonts to your R session by searching their repository for a specified font family. The `name` argument is the actual name of the font on Google Fonts, while the `family` argument is a custom name you create to reference that font in your code.

## II. Data wrangling

### i. Create `df_pop`

```{r}
#| eval: false
#| echo: true

df_pop <- places |>
  filter(country_code == "US") |>
  mutate(state = str_replace(string = state,
                             pattern = "Fl",
                             replacement = "FL")) |> 
  group_by(state) |>
  summarise(pop = sum(population)) |>
  ungroup()
```

3.  **Describe what this data frame contains.**

    -   This data frame contains one column called `state` with USA state abbreviations and another column called `pop` with the total population of each state, with a total of 51 rows.

### ii. Create `df_us`

```{r}
#| eval: false
#| echo: true

df_us <- ufo_sightings |>
  filter(country_code == "US") |>
  mutate(state = str_replace(string = state,
                             pattern = "Fl",
                             replacement = "FL")) |> 
  count(state) |>
  left_join(df_pop, by = "state") |>
  rename(num_obs = n) |> 
  mutate(
    num_obs_per10k = num_obs / pop * 10000,
    opacity_val = num_obs_per10k / max(num_obs_per10k)
    )
```

4.  **Describe what this data frame contains.**

    -   This data frame contains 5 columns and 51 rows. The variables are: `state` (USA state abbreviations), `num_obs` (number of UFO sightings in each state), `pop` (total population of each state), `num_obs_per10k` (number of UFO sightings per 10,000 people), and `opacity_val` (a normalized value between 0 and 1 based on the sighting rate)

5.  **What does `opacity_val` represent, and why is it calculated?**

    -   The `opacity_val` represents a normalized transparency value ranging from 0 to 1. The author calculated by dividing each state's UFO sighting rate per 10,000 people by the maximum sighting rate across all states. This allows the opacity values to be used for visualization purposes, where states with higher sighting rates can be displayed with higher opacity (more visible) and states with lower sighting rates with lower opacity (more transparent).

### iii. Create `df_shape`

```{r}
#| eval: false
#| echo: true

df_shape <- ufo_sightings |>
  filter(!shape %in% c("unknown", "other")) |>
  count(shape) |>
  rename(total_sightings = n) |> 
  arrange(desc(total_sightings)) |>
  slice_head(n = 10) |>
  mutate(
    shape = fct_reorder(.f = shape, 
                        .x = total_sightings), 
    opacity_val = scales::rescale(x = total_sightings, 
                                  to = c(0.3, 1))
    )
```

6.  **Describe what this data frame contains.**

    -   This data frame contains 3 columns and 10 rows. The variables are: `shape` (the shape of UFO sightings, excluding "unknown" and "other"), `total_sightings` (the total number of sightings for each shape), and `opacity_val` (rescaled transparency value between 0.3 and 1 based on the number of sightings). The data frame shows the top 10 most commonly reported UFO shapes, ordered by frequency.

7.  **What does `fct_reorder` do when it is applied to the `shape` variable? What would have happened if this step was not performed?**

    -   `fct_reorder` converts the `shape` variable into a factor and orders its levels based on the values in `total_sightings`. This ensures that when the data is plotted, the shapes will appear in order from lowest to highest sighting counts. If this step was not performed, the shapes would be ordered alphabetically by default, which wouldn't meaningfully represent the data and would make the visualization harder to interpret.

8.  **What is the purpose of rescaling `opacity_val`? And why rescale from 0.3 to 1?**

    -   The purpose of rescaling `opacity_val` is to map the sighting counts to a usable opacity range for visualization. By rescaling from 0.3 to 1 instead of 0 to 1, it ensures that even the shapes with the lowest sighting counts remain visible in the plot rather than being completely transparent.

### iv. Create `df_day_hour`

```{r}
#| eval: false
#| echo: true

df_day_hour <- ufo_sightings |>
  mutate(
    day = wday(reported_date_time), 
    hour = hour(reported_date_time), 
    wday = wday(reported_date_time, label = TRUE) 
  ) |>
  count(day, wday, hour) |>
  rename(total_daily_obs = n) |> 
  mutate(
    opacity_val = total_daily_obs / max(total_daily_obs),
    hour_lab = case_when(
      hour == 0 ~ "12am",
      hour <= 12 ~ paste0(hour, "am"),
      hour == 12 ~ "12pm",
      TRUE ~ paste0(hour - 12, "pm")) 
    )
```

9.  **Describe what this data frame contains.**

    -   This data frame contains 6 columns and 168 rows representing UFO sightings aggregated by day of the week and hour of the day. The variables are: `day` (numeric day of the week, 1-7), `wday` (labeled day of the week like "Mon", "Tue"), `hour` (hour of the day), `total_daily_obs` (count of UFO sightings for each day-hour combination), `opacity_val` (normalized transparency value between 0 and 1 based on sighting counts), and `hour_lab` (formatted hour labels)

10. **What is the purpose of the last line inside the `case_when()` statement (`TRUE ~ paste0(hour - 12, "pm")`)?**

    -   The purpose is to convert hours from military time (24-hour format) to regular time (12-hour format). This last line handles all the afternoon and evening hours (13-23) by subtracting 12 and adding "pm"

## III. Prepare text elements

```{r}
#| eval: false
#| echo: true

quotes <- paste0('"...', str_to_sentence(ufo_sightings$summary[c(47816, 6795, 93833)]), '..."')

original <- glue("Original visualization by Dan Oehm:")
dan_github <- glue("<span style='font-family:fa-brands;'>&#xf09b;</span> doehm/tidytues")
new <- glue("Updated version by Sam Shanny-Csik for EDS 240:")
link <- glue("<span style='font-family:fa-solid;'>&#xf0c1;</span> eds-240-data-viz.github.io")
space <- glue("<span style='color:{bg};'>. .</span>")
caption <- glue("{original}{space}{dan_github}
                <br><br>
                {new}{space}{link}")
```

11. **In your own words, what is the difference between `paste0()` and `glue()`? Why did the author use `paste0` to construct `quotes` and `glue` to construct the other text elements?**

    -   `The paste0()` sticks strings together, while `glue()` lets you insert variables directly into your text using `{}`. The author used `paste0()` for quotes because it was just combining simple text pieces. They used `glue()` for the other elements because those needed to include variables like color values and make the code easier to read

## IV. Build plots

### i. Build `plot_shape`

```{r}
#| eval: false
#| echo: true

plot_shape <- ggplot(data = df_shape) +
  geom_col(aes(x = total_sightings, y = shape, alpha = opacity_val), 
           fill = accent) +
  geom_text(aes(x = 200, y = shape, label = str_to_title(shape)), 
            family = "orb", 
            fontface = "bold",
            color = bg, 
            size = 14, 
            hjust = 0,
            nudge_y = 0.2) +
  geom_text(aes(x = total_sightings-200, y = shape, label = scales::comma(total_sightings)),
            family = "orb",
            fontface = "bold",
            color = bg,
            size = 10,
            hjust = 1,
            nudge_y = -0.2) +
  scale_x_continuous(expand = c(0, NA)) +
  labs(subtitle = "10 most commonly reported shapes") +
  theme_void() +
  theme(
    plot.subtitle = element_text(family = "bar", 
                                 size = 40, 
                                 color = accent,
                                 hjust = 0,  
                                 margin = margin(b = 10)),
    legend.position = "none" 
  )
```

12. **Explain the values provided to the `x` aesthetic for both text geoms (`shape` & `total_sightings`).**

    -   The first geom_text uses x = 200, which places the shape names at a fixed position 200 units from the left edge of the plot. The second geom_text uses x = total_sightings - 200, which positions the sighting counts 200 units to the left of each bar's end. This creates spacing where the shape names appear near the start of the bars and the counts appear near the end of the bars.

### ii. Build `plot_us`

**HINT:** Consider temporarily commenting out / rearranging the `geom_*()` layers to better understand how this plot is constructed

```{r}
#| eval: false
#| echo: true

plot_us <-  ggplot(df_us) +
  geom_rect(aes(xmin = 0, xmax = 1, ymin = 0, ymax = 1, alpha = opacity_val), 
            fill = accent) +
  geom_text(aes(x = 0.5, y = 0.7, label = state), 
            family = "orb", 
            fontface = "bold",
            size = 9, 
            color = bg) +
  geom_text(aes(x = 0.5, y = 0.3, label = round(num_obs_per10k, 1)), 
            family = "orb", 
            fontface = "bold",
            size = 8, 
            color = bg) +  
  geofacet::facet_geo(~state) +
  coord_fixed(ratio = 1) +
  labs(subtitle = "Sightings per 10k population") +
  theme_void() +
  theme(
    strip.text = element_blank(),
    plot.subtitle = element_text(family = "bar", 
                                 size = 40, 
                                 color = accent,
                                 hjust = 1,  
                                 margin = margin(b = 10)),
    legend.position = "none" 
  )
```

13. **Consider the order of `geom_*()` layers in the the above plot (`plot_us`). Why did the author order the layers in this way?**

    -   The author ordered the layers so that geom_rect comes first, creating the colored rectangles as the background. Then the two geom_text layers are added on top, which places the state abbreviations and sighting rates over the rectangles. This layering order ensures the text is visible and not hidden behind the rectangles.

### iii. Build `plot_day`

```{r}
#| eval: false
#| echo: true

plot_day <- ggplot(data = df_day_hour) +
  geom_tile(aes(x = hour, y = day, alpha = opacity_val), 
            fill = accent, 
            height = 0.9, 
            width = 0.9) +
  geom_text(aes(x = hour, y = 9, label = hour_lab), 
            family = "orb",
            color = accent, 
            size = 10) +
  geom_text(aes(x = 0, y = day, label = str_sub(string = wday, start = 1, end = 1)), 
            family = "orb", 
            fontface = "bold",
            color = bg, 
            size = 8) + 
  ylim(-5, 9) +
  xlim(NA, 23.55) +
  coord_polar() +
  theme_void() +
  theme(
    plot.background = element_rect(fill = bg, color = bg),
    legend.position = "none"
  )
```

14. **This plot includes one-letter labels for each day of the week. How is this accomplished when week days are written using their three-letter abbreviations (e.g. `Mon`, `Tue`) in the `df_day_hour` data frame?**

    -   This is accomplished using str_sub(string = wday, start = 1, end = 1) inside the geom_text layer. The str_sub() function extracts only the first character from each three-letter day abbreviation.

15. **What role do the `ylim()` and `xlim()` functions play in shaping a ggplot, and how do they change the visual layout of this particular plot? To better understand their effect, try rerunning the code with each of these lines commented out and observe how the plot’s spacing and composition change.**

    -   ylim() and xlim() set the limits for the y-axis and x-axis. In this plot, ylim(-5, 9) extends the y-axis range below 0 and above 7, which decreases the empty space in the center of the circle. xlim(NA, 23.55) slightly extends the right side of the x-axis to add a small gap between 11pm and 12am when wrapped into a circle. Without these adjustments, the days of the week on the plot look tightly packed without spaces.

### iv. Build `quote*`s

A comment from Dan Oehm's original code: "A bit clunky but the path of least resistance."

```{r}
#| eval: false
#| echo: true

quote1 <- ggplot() +
  annotate(geom ="text", 
           x = 0, 
           y = 1, 
           label = str_wrap(string = quotes[1], width = 40),
           family = "bar", 
           fontface = "italic", 
           color = accent, 
           size = 16, 
           hjust = 0, 
           lineheight = 0.4) +
  xlim(0, 1) +
  ylim(0, 1) +
  theme_void() +
  coord_cartesian(clip = "off")

quote2 <- ggplot() +
  annotate(geom = "text", 
           x = 0, 
           y = 1, 
           label = str_wrap(string = quotes[2], width = 25),
           family = "bar", 
           fontface = "italic",
           color = accent, 
           size = 16, 
           hjust = 0,  
           lineheight = 0.4) +
  xlim(0, 1) +
  ylim(0, 1) +
  theme_void() +
  coord_cartesian(clip = "off")

quote3 <- ggplot() +
  annotate(geom = "text", 
           x = 0, 
           y = 1, 
           label = str_wrap(string = quotes[3], width = 25),
           family = "bar", 
           fontface = "italic",
           color = accent, 
           size = 16, 
           hjust = 0,  
           lineheight = 0.4) +
  xlim(0, 1) +
  ylim(0, 1) +
  theme_void() +
  coord_cartesian(clip = "off")
```

16. **Why do you think the author chose to convert these text elements (and also in `plot_ufo`, below!) into ggplot objects (you may consider returning to this question after you've worked your way through all of the code)?**

    -   Turning everything into ggplot objects enables easier positioning, scaling, and layering, which facilitates the poster-style composition.

### v. Build `plot_ufo`

**Note:** Grob stands for **gr**aphical **ob**ject. Each visual element rendered in a a ggplot (e.g. lines, points, axes, entire panels, even images) is represented as a grob. Grobs can be manipulated individually to fully customize plots.

```{r}
#| eval: false
#| echo: true

plot_ufo <- ggplot() +
  annotation_custom(grid::rasterGrob(ufo_image)) +
  theme_void() +
  theme(
    plot.background = element_rect(fill = bg, color = bg) 
  )
```

### vi. Build `plot_base`

```{r}
#| eval: false
#| echo: true

plot_base <- ggplot() +
  labs(
    title = "UFO Sightings",
    subtitle = "Summary of over 88k reported sightings across the US",
    caption = caption
    ) +
  theme_void() +
  theme(
    text = element_text(family = "orb", 
                        size = 48, 
                        lineheight = 0.3, 
                        color = accent),
    plot.background = element_rect(fill = bg, 
                                   color = bg),
    plot.title = element_text(size = 128, 
                              face = "bold", 
                              hjust = 0.5, 
                              margin = margin(b = 10)),
    plot.subtitle = element_text(family = "bar", 
                                 hjust = 0.5, 
                                 margin = margin(b = 20)),
    plot.caption = ggtext::element_markdown(family = "bar",
                                            face = "italic",
                                            color = colorspace::darken(accent, 0.25),
                                            hjust = 0.5,
                                            margin = margin(t = 20)),
    plot.margin = margin(b = 20, t = 50, r = 50, l = 50)
  )
```

17. **Why does the author render `plot.caption` using `ggtext::element_markdown()`, rather than `element_text()` (like he does for rendering `plot.title` and `text`)?**

    -   The author uses ggtext::element_markdown() for the caption because it allows rendering of Markdown formatting within the text, such as bold, italics, links, or other styled elements.

## V. Assemble & save

```{r}
#| eval: false
#| echo: true

plot_final <- plot_base +
  inset_element(plot_shape, left = 0, right = 1, top = 1, bottom = 0.66) +
  inset_element(plot_us, left = 0.42, right = 1, top = 0.74, bottom = 0.33) +
  inset_element(plot_day, left = 0, right = 0.66, top = 0.4, bottom = 0) +
  inset_element(quote1, left = 0.5, right = 1, top = 0.8, bottom = 0.72) +
  inset_element(quote2, left = 0, right = 1, top = 0.52, bottom = 0.4) +
  inset_element(quote3, left = 0.7, right = 1, top = 0.2, bottom = 0) +
  inset_element(plot_ufo, left = 0.25, right = 0.41, top = 0.23, bottom = 0.17) + 
  plot_annotation(
    theme = theme(
      plot.background = element_rect(fill = bg,
                                     color = bg)
    )
  ) 

ggsave(plot = plot_final, 
       filename = here::here("outputs", "ufo_sightings_infographic.png"), 
       height = 16, 
       width = 10)
```

18. **Explain how `plot_final` is assembled. What do you think is the most challenging aspect of arranging all components into a single plot?**

    -   plot_final is assembled by starting with plot_base as the foundation and then layering individual plot components using inset_element(). Each component is positioned using coordinates that specify where it should appear (left, right, top, bottom values between 0 and 1). The most challenging aspect is likely determining the precise positioning coordinates for each element to avoid overlaps while creating a composition that maintains readability.

19. **Can you think of one reason the author may have chosen to separate the construction of `plot_base` and `plot_final`?**

    -   I think that separating plot_base and plot_final allows for better code organization and easier troubleshooting. By building the base layer with titles, captions, and overall theme settings separately, the author can test and modify the foundation independently before adding the complexity of positioning multiple plot elements.

## Answer some final reflective questions

20. **During week 2, we discuss [Choosing the right graphic form](https://eds-240-data-viz.github.io/course-materials/lecture-slides/lecture2.1-choosing-graphic-forms-slides.html#/title-slide). Refer to this lecture when answering the sub-questions, below:**

    a.  **What "perceptual tasks" (from Cleveland & McGill's heirarchy) must the viewer perform to extract information from these visualizations?**

        -   The three main visualizations require different perceptual tasks. The UFO shape visualization uses a bar plot to compare counts across different shape categories, with higher transparency indicating lower counts. The US map visualization requires judging color shading and position on a spatial map to understand the geographic distribution of sightings. The time-of-day visualization uses shading and angles, since it is a circular plot, which ranks lower in the perceptual hierarchy and is potentially more challenging for accurate interpretation than the first graph.

    b.  **What task(s) do you think the author wanted to enable or message(s) he wanted to convey with these visualizations (see lecture 2.1, slide 16 for examples)? Be sure to note at least one task / message for each of the three data viz.**

        -   For the UFO shape visualization, the author wanted to enable comparison of which shapes are most commonly reported. I think he wanted to make a connection between the shape "light" being the most frequent category by representing it as brighter. For the US map, I believe the message is to reveal geographic patterns and show where sightings are concentrated across different states. For the time-of-day visualization, I think the goal is to show temporal patterns and enable viewers to see when sightings peak throughout the day and week, with the plot design resembling a clock to reinforce this temporal theme.

    c.  **Name at least one caveat to the "hierarchy of perceptual tasks" that the author employed to achieve a goal(s) you noted in question b?**

        -   The author used a map visualization despite spatial position not being at the top of the perceptual hierarchy, because showing geographic distribution was essential to the message. The familiarity of the US map shape makes it intuitive for viewers to understand regional patterns, even though extracting precise values from color intensity is less accurate than other methods.

21. **Describe two elements of this piece that you find visually-pleasing / easy to understand / intuitive. Why?**

    -   I think that the color scheme is intuitive and thematic, using dark backgrounds with accent colors that convey a UFO aesthetic. The use of the UFO image as a decorative element is visually pleasing and reinforces the theme without cluttering the information.

22. **Describe two elements of this piece that you feel could be better presented in a different way. Why?**

    -   The time-of-day visualization with multiple small line charts could be challenging to compare accurately across days, a heat map might make temporal patterns easier to identify. Additionally, the quotes scattered throughout are somewhat distracting from the main analytical insights. Consolidating or repositioning them might improve focus on the data story.

23. **Describe two new things that you learned by interpreting / annotating this code. These could be packages, functions, or even code organizational approaches that you hadn't previously known about or considered.**

    -   I learned about the modular approach of creating separate ggplot objects for different components and then assembling them using inset_element() with coordinate positioning, which provides more control over layout. I also learned about converting text elements into ggplot objects using ggtext::element_markdown(), which allows for richer formatting and enables treating text as graphical objects that can be positioned and layered like any other plot component.

24. **How, if at all, did you use AI tools to help you interpret this code? Describe your approach to using these tools for this assignment. In what ways was consulting the documentation more (or less) helpful than using AI?**

    -   I used AI tools to understand the purpose of unfamiliar syntax and to clarify more complex code structures, which saved time compared to searching through documentation. However, consulting the official documentation was more helpful for understanding the specific parameter behavior of functions and more accurate with respect to functionality. Considering the easy access of the help pages in R and the examples provided, it ended up being pretty quick.
